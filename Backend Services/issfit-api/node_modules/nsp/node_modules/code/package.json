{
  "_args": [
    [
      {
        "raw": "code@https://registry.npmjs.org/code/-/code-1.5.0.tgz",
        "scope": null,
        "escapedName": "code",
        "name": "code",
        "rawSpec": "https://registry.npmjs.org/code/-/code-1.5.0.tgz",
        "spec": "https://registry.npmjs.org/code/-/code-1.5.0.tgz",
        "type": "remote"
      },
      "/var/tmp/NTL-ISS-Food-Intake-Tracker/Backend Services/issfit-api/node_modules/nsp"
    ]
  ],
  "_from": "code@https://registry.npmjs.org/code/-/code-1.5.0.tgz",
  "_id": "code@1.5.0",
  "_inCache": true,
  "_location": "/nsp/code",
  "_phantomChildren": {},
  "_requested": {
    "raw": "code@https://registry.npmjs.org/code/-/code-1.5.0.tgz",
    "scope": null,
    "escapedName": "code",
    "name": "code",
    "rawSpec": "https://registry.npmjs.org/code/-/code-1.5.0.tgz",
    "spec": "https://registry.npmjs.org/code/-/code-1.5.0.tgz",
    "type": "remote"
  },
  "_requiredBy": [],
  "_resolved": "https://registry.npmjs.org/code/-/code-1.5.0.tgz",
  "_shasum": "d6159fbd0ee9f8445167809d43b5cd9bc405103a",
  "_shrinkwrap": null,
  "_spec": "code@https://registry.npmjs.org/code/-/code-1.5.0.tgz",
  "_where": "/var/tmp/NTL-ISS-Food-Intake-Tracker/Backend Services/issfit-api/node_modules/nsp",
  "bugs": {
    "url": "https://github.com/hapijs/code/issues"
  },
  "dependencies": {
    "hoek": "2.x.x"
  },
  "description": "assertion library",
  "devDependencies": {
    "lab": "5.x.x"
  },
  "engines": {
    "node": ">=0.10.32"
  },
  "homepage": "https://github.com/hapijs/code#readme",
  "keywords": [
    "test",
    "expect",
    "assertion"
  ],
  "license": "BSD-3-Clause",
  "main": "lib/index.js",
  "name": "code",
  "optionalDependencies": {},
  "readme": "#code\n\nBDD assertion library.\n\n[![Current Version](https://img.shields.io/npm/v/code.svg)](https://www.npmjs.org/package/code)\n[![Build Status](https://secure.travis-ci.org/hapijs/code.png)](http://travis-ci.org/hapijs/code)\n\nLead Maintainer - [Colin Ihrig](https://github.com/cjihrig)\n\n## Table of Contents\n\n- [Example](#example)\n- [Acknowledgments](#acknowledgments)\n- [Usage](#usage)\n    - Grammar\n    - Flags\n    - [`expect(value, [prefix])`](#expectvalue-prefix)\n        - Types\n            - [`arguments()`](#arguments)\n            - [`array()`](#array)\n            - [`boolean()`](#boolean)\n            - [`buffer()`](#buffer)\n            - [`date()`](#date)\n            - [`function()`](#function)\n            - [`number()`](#number)\n            - [`regexp()`](#regexp)\n            - [`string()`](#string)\n            - [`object()`](#object)\n        - Values\n            - [`true()`](#true)\n            - [`false()`](#false)\n            - [`null()`](#null)\n            - [`undefined()`](#undefined)\n        - [`include(values)`](#includevalues)\n        - [`startWith(value)`](#startwithvalue)\n        - [`endWith(value)`](#startwithvalue)\n        - [`exist()`](#exist)\n        - [`empty()`](#empty)\n        - [`length(size)`](#lengthsize)\n        - [`equal(value)`](#equalvalue)\n        - [`above(value)`](#abovevalue)\n        - [`least(value)`](#leastvalue)\n        - [`below(value)`](#belowvalue)\n        - [`most(value)`](#mostvalue)\n        - [`within(from, to)`](#withinfrom-to)\n        - [`about(value, delta)`](#aboutvalue-delta)\n        - [`instanceof(type)`](#instanceoftype)\n        - [`match(regex)`](#matchregex)\n        - [`satisfy(validator)`](#satisfyvalidator)\n        - [`throw([type], [message])`](#throwtype-message)\n    - [`count()`](#count)\n    - [`incomplete()`](#incomplete)\n    - [Settings](#settings)\n        - [`truncateMessages`](#truncatemessages)\n        - [`comparePrototypes`](#compareprototypes)\n\n## Example\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(true).to.be.a.boolean().and.to.not.equal(false);\nexpect('this string').to.only.include(['this', 'string']);\n```\n\n## Acknowledgments\n\n**code** was created as a direct rewrite of the powerful [**chai**](http://chaijs.com) assertions\nlibrary. This virtual fork was created for a few reasons. First, **chai** mixed usage of methods and\nproperties creates a problematic environment in which it is too easy to forget a method `()` and result\nin an assertion that is never executed (and therefor passes incorrectly). This observation was noted by\nthe [**must**](https://github.com/moll/js-must) author.\n\nThe second reason is that similar to [**lab**](https://github.com/hapijs/lab), our test runner, we wanted\nan assertion library that is small, simple, and intuitive - without plugins, extensions, or the overhead\nof having to support testing in the browser. **code** provides much of the same functionality is about\n300 lines of code that are trivial to read in a few minutes.\n\nAnd last, we wanted to experiment with some new features that allow deeper integration between the test\nrunner and assertions library. The first of which are two methods exported (and used by **lab**) for getting\nthe total assertions count (which is a measure of the tests comprehensiveness), and by verifying that every\nassertion created (e.g. every `expect()` call) is also executed. This will alert when a statement like\n`expect(5).to.be.a.string` is not allowed to remain unnoticed (and fail to throw due to the missing `()`).\n\nLike **lab**, the goal is to keep this module small and simple. If you need extensibility or other\nfunctionality, we recommend looking at the many other excellent assertions libraries available.\n\n## Usage\n\n### Grammar\n\n**code** supports usage of connecting words to make assertions more readable. The inclusion of these\ngrammar elements has no impact over the assertion outcome and are used for human readability only.\nEvery method or property of the assertion object returned by `expect()` returns `this` which allows\nchaining addition assertions or grammar words.\n\nThe supported words are:\n- `a`\n- `an`\n- `and`\n- `at`\n- `be`\n- `have`\n- `in`\n- `to`\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(10).to.be.above(5);\nexpect('abc').to.be.a.string();\nexpect([1, 2]).to.be.an.array();\nexpect(20).to.be.at.least(20);\nexpect('abc').to.have.length(3);\nexpect('abc').to.be.a.string().and.contain(['a', 'b']);\nexpect(6).to.be.in.range(5, 6);\n```\n\n### Flags\n\nThe following words toggle a status flag for the current assertion:\n- `deep` - performs a deep comparison instead of simple equality (`===`). Required when trying to compare\n  objects to an identical copy that is not the same reference. Used by `equal()` and `include()`.\n- `not` - inverses the expected result of any assertion.\n- `once` - requires that inclusion matches appear only once in the provided value. Used by `include()`.\n- `only` - requires that only the provided elements appear in the provided value. Used by `include()`.\n- `part` - allows a partial match when asserting inclusion. Used by `include()`.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(10).to.not.be.above(20);\nexpect([{ a: 1 }]).to.deep.include({ a: 1 });\nexpect([1, 1, 2]).to.only.include([1, 2]);\nexpect([1, 2]).to.once.include([1, 2]);\nexpect([1, 2, 3]).to.part.include([1, 4]);\n```\n\nNote that including the same flag twice toggles the last value set. This is especially important when\nchaining multiple assertions in a single statement (e.g. when using the `and` grammar word).\n\n### `expect(value, [prefix])`\n\nGenerates an assertion object where:\n- `value` - the reference value on which to apply the assertion rules.\n- `prefix` - an optional string used as an error message prefix.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(10, 'Age').to.be.above(5);\n```\n\n#### Types\n\nAsserts that the reference value is of a certain type.\n\n##### `arguments()`\n\nAsserts that the reference value is an `arguments` object.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nvar func = function () { return arguments; };\nexpect(func()).to.be.arguments();\n```\n\n##### `array()`\n\nAsserts that the reference value is an `Array`.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect([1, 2]).to.be.an.array();\n```\n\n##### `boolean()`\n\nAsserts that the reference value is a boolean.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(true).to.be.a.boolean();\n```\n\n##### `buffer()`\n\nAsserts that the reference value is a `Buffer`.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(new Buffer('')).to.be.a.buffer();\n```\n\n##### `date()`\n\nAsserts that the reference value is a `Date`.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(new Date()).to.be.a.date();\n```\n\n##### `function()`\n\nAsserts that the reference value is a `function`.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(function () {}).to.be.a.function();\n```\n\n##### `number()`\n\nAsserts that the reference value is a `number`.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(123).to.be.a.number();\n```\n\n##### `regexp()`\n\nAsserts that the reference value is an `RegExp`.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(/abc/).to.be.a.regexp();\n```\n\n##### `string()`\n\nAsserts that the reference value is a string.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect('abc').to.be.a.string();\n```\n\n##### `object()`\n\nAsserts that the reference value is an object (excluding array, buffer, or other native objects).\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect({ a: '1' }).to.be.an.object();\n```\n\n#### Values\n\nAsserts that the reference value is equals to a predefined value.\n\n##### `true()`\n\nAsserts that the reference value is true.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(true).to.be.true();\n```\n\n##### `false()`\n\nAsserts that the reference value is false.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(false).to.be.false();\n```\n\n##### `null()`\n\nAsserts that the reference value is null.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(null).to.be.null();\n```\n\n##### `undefined()`\n\nAsserts that the reference value is undefined.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(undefined).to.be.undefined();\n```\n\n#### `include(values)`\n\nAliases: `includes()`, `contain()`, `contains()`\n\nAsserts that the reference value (a string, array, or object) includes the provided values where:\n- `values` - a single or array of values. If the reference value is a string, the values must be strings.\n  If the reference value is an array, the values can be any array member (`deep` is required to compare\n  non-literal types). If the reference value is an object, the values can be key names, or a single object\n  with key-value pairs to match.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect('abc').to.include('ab');\nexpect('abc').to.only.include('abc');\nexpect('aaa').to.only.include('a');\nexpect('abc').to.once.include('b');\nexpect('abc').to.include(['a', 'c']);\nexpect('abc').to.part.include(['a', 'd']);\n\nexpect([1, 2, 3]).to.include(1);\nexpect([{ a: 1 }]).to.deep.include({ a: 1 });\nexpect([1, 2, 3]).to.include([1, 2]);\nexpect([{ a: 1 }]).to.deep.include([{ a: 1 }]);\nexpect([1, 1, 2]).to.only.include([1, 2]);\nexpect([1, 2]).to.once.include([1, 2]);\nexpect([1, 2, 3]).to.part.include([1, 4]);\nexpect([[1], [2]]).to.deep.include([[1]]);\n\nexpect({ a: 1, b: 2, c: 3 }).to.include('a');\nexpect({ a: 1, b: 2, c: 3 }).to.include(['a', 'c']);\nexpect({ a: 1, b: 2, c: 3 }).to.only.include(['a', 'b', 'c']);\nexpect({ a: 1, b: 2, c: 3 }).to.include({ a: 1 });\nexpect({ a: 1, b: 2, c: 3 }).to.include({ a: 1, c: 3 });\nexpect({ a: 1, b: 2, c: 3 }).to.part.include({ a: 1, d: 4 });\nexpect({ a: 1, b: 2, c: 3 }).to.only.include({ a: 1, b: 2, c: 3 });\nexpect({ a: [1], b: [2], c: [3] }).to.deep.include({ a: [1], c: [3] });\n```\n\n#### `startWith(value)`\n\nAliases: `startsWith()`,\n\nAsserts that the reference value (a string) starts with the provided value where:\n- `value` - a string.\n\nNote that this assertion is case sensitive.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect('https://example.org/secure').to.startWith('https://');\n```\n\n#### `endWith(value)`\n\nAliases: `endsWith()`,\n\nAsserts that the reference value (a string) ends with the provided value where:\n- `value` - a string.\n\nNote that this assertion is case sensitive.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect('http://example.org/relative').to.endWith('/relative');\n```\n\n#### `exist()`\n\nAliases: `exists`\n\nAsserts that the reference value exists (not `null` or `undefined`).\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(4).to.exist();\nexpect(null).to.not.exist();\n```\n\n\n#### `empty()`\n\nAsserts that the reference value has a `length` property equal to zero or an object with no keys.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect('abc').to.be.empty();\n```\n\n#### `length(size)`\n\nAsserts that the reference value has a `length` property matching the provided size or an object with the\nspecified number of keys where:\n- `size` - the required size.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect('abcd').to.have.length(4);\n```\n\n#### `equal(value[, options])`\n\nAliases: `equals()`\n\nAsserts that the reference value equals the provided value (`deep` is required to compare non-literal\ntypes) where:\n- `value` - the value to compare to.\n- `options` - optional object specifying comparison options. This is only used on\ndeep comparisons, and is ignored otherwise.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(5).to.equal(5);\nexpect({ a: 1 }).to.deep.equal({ a: 1 });\n```\n\nDeep comparisons are performed using\n[`Hoek.deepEqual()`](https://github.com/hapijs/hoek#deepequalb-a-options). The\noptional `options` argument is passed directly to `Hoek.deepEqual()`. An example\ndeep comparison which ignores object prototypes is shown below.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(Object.create(null)).to.deep.equal({}, { prototype: false });\n```\n\n#### `above(value)`\n\nAliases: `greaterThan()`\n\nAsserts that the reference value is greater than (`>`) the provided value where:\n- `value` - the value to compare to.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(10).to.be.above(5);\n```\n\n#### `least(value)`\n\nAliases: `min()`\n\nAsserts that the reference value is at least (`>=`) the provided value where:\n- `value` - the value to compare to.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(10).to.be.at.least(10);\n```\n\n#### `below(value)`\n\nAliases: `lessThan()`\n\nAsserts that the reference value is less than (`<`) the provided value where:\n- `value` - the value to compare to.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(10).to.be.below(20);\n```\n\n#### `most(value)`\n\nAliases: `max()`\n\nAsserts that the reference value is at most (`<=`) the provided value where:\n- `value` - the value to compare to.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(10).to.be.at.most(10);\n```\n\n#### `within(from, to)`\n\nAliases: `range()`\n\nAsserts that the reference value is within (`from <= value <= to`) the provided values where:\n- `from` - the start of the range (inclusive).\n- `to` - the end of the range (inclusive).\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(10).to.be.within(10, 20);\nexpect(20).to.be.within(10, 20);\n```\n\n#### `between(from, to)`\n\nAsserts that the reference value is between but not equal (`from < value < to`) the provided values where:\n- `from` - the start of the range (exclusive).\n- `to` - the end of the range (exclusive).\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(15).to.be.between(10, 20);\n```\n\n#### `about(value, delta)`\n\nAsserts that the reference value is about the provided value within a delta margin of difference where:\n- `value` - the value to compare to.\n- `delta` - the allowed margin of difference.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(10).to.be.about(9, 1);\n```\n\n#### `instanceof(type)`\n\nAliases: `instanceOf()`\n\nAsserts that the reference value has the provided `instanceof` value where:\n- `type` - the type value to match.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(new Date()).to.be.an.instanceof(Date);\n```\n\n#### `match(regex)`\n\nAliases: `matches()`\n\nAsserts that the reference value is a string matching the provided regular expression where:\n- `regex` - the regular expression to match.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect('a5').to.match(/\\w\\d/);\n```\n\n#### `satisfy(validator)`\n\nAliases: `satisfies()`\n\nAsserts that the reference value satisfies the provided validator function where:\n- `validator` - a function with the signature `function(value)` with return value `true` or `false`. The\n  reference value is passed as the only argument to the `validator` function and the assertion passes if\n  the return value is `true`.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect('x').to.satisfy(function (value) { return value === 'x'; });\n```\n\n#### `throw([type], [message])`\n\nAliases: `throws`\n\nAsserts that the function reference value throws an exception when called. The provided reference function\nis invoked within a `try`-`catch` block and any error throws is caught and compared to the provided optional\nrequirements where:\n- `type` - the `instanceof` value of the thrown object.\n- `message` a string or regular expression matching the thrown error `message` property. Note that a string\n  must provide a full match.\n\n```js\nvar NodeUtil = require('util');\nvar Code = require('code');\nvar expect = Code.expect;\n\nvar CustomError = function (message) {\n\n    Error.call(this, message);\n};\n\nNodeUtil.inherit(CustomError, Error)\n\nvar throws = function () {\n\n    throw new CustomError('Oh no!');\n};\n\nexpect(throws).to.throw(CustomError, 'Oh no!');\n```\n\n### `count()`\n\nReturns the total number of assertions created using the `expect()` method.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(5).to.not.be.a.string();\nconsole.log(Code.count());\t\t// -> 1\n```\n\n### `incomplete()`\n\nReturns an array of the locations where incomplete assertions were declared or `null` if\nno incomplete assertions found.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\n\nexpect(5).to.not.be.a.string;\nconsole.log(Code.incomplete());\t\t// -> [ 'readme.js:345:1' ]\n```\n\n### Settings\n\n**code** can be configured using the module's `settings` object. The following\nsettings are supported:\n\n#### `truncateMessages`\n\nA Boolean value that, when `true`, causes long assertion error messages to be\ntruncated for readability. Setting this to `false` causes the entire message\nto be displayed. Defaults to `true`.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\nvar foo = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n\nCode.settings.truncateMessages = false;\nexpect(foo).to.deep.equal([]);\n```\n\n#### `comparePrototypes`\n\nA boolean value that, when `false`, ignores object prototypes when doing a deep comparison. Defaults to `true`.\n\n```js\nvar Code = require('code');\nvar expect = Code.expect;\nvar foo = Object.create(null);\n\nCode.setting.comparePrototypes = false;\nexpect(foo).to.deep.equal({});\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/hapijs/code.git"
  },
  "scripts": {
    "test": "lab -v -t 100 -L",
    "test-cov-html": "lab -L -r html -o coverage.html"
  },
  "version": "1.5.0"
}
