diff --git a/BNPieChart.h b/BNPieChart.h
index ad23f44..b4a0dba 100644
--- a/BNPieChart.h
+++ b/BNPieChart.h
@@ -40,6 +40,7 @@
 	
 	NSMutableArray* sliceNames;
 	NSMutableArray* nameLabels;
+    NSMutableArray* images;
   
   // Has BNColor elements.  If #slices > #colors, the colors cycle.
   // When nil (default), uses autogenerated colors and never cycles.
@@ -55,9 +56,12 @@
 
 // Adds a slice with the given portion (fraction in the range 0.0-1.0),
 // and name.  The name may be nil.
-- (void)addSlicePortion:(float)slicePortion withName:(NSString *)name;
+- (void)addSlicePortion:(float)slicePortion withName:(NSString *)name andImage:(UIImage *)image;
 
 // Creates a sample pie chart in the given frame.
 + (BNPieChart *)pieChartSampleWithFrame:(CGRect)frame;
 
+// Whether to show the labels
+- (void)showLabels:(BOOL)show;
+
 @end
diff --git a/BNPieChart.m b/BNPieChart.m
index c9ee5ca..c35b33c 100644
--- a/BNPieChart.m
+++ b/BNPieChart.m
@@ -28,7 +28,9 @@
 - (void)addLabelForLastName;
 - (void)getRGBForIndex:(int)index red:(float *)red green:(float *)green blue:(float *)blue;
 - (float)approxDistFromCenter:(CGRect)rect;
+- (void)moveInImage:(int)index;
 - (void)moveInLabel:(int)index;
+- (void)movePreviousImagessIn;
 - (void)movePreviousLabelsIn;
 - (float)pointAtIndex:(int)index;
 
@@ -43,13 +45,13 @@
 + (BNPieChart *)pieChartSampleWithFrame:(CGRect)frame {
 	BNPieChart *chart = [[[BNPieChart alloc]
                         initWithFrame:frame] autorelease];
-	[chart addSlicePortion:0.1 withName:@"Orange"];
-	[chart addSlicePortion:0.2 withName:@"Fandango"];
-	[chart addSlicePortion:0.1 withName:@"Blue"];
-	[chart addSlicePortion:0.1 withName:@"Cerulean"];
-	[chart addSlicePortion:0.3 withName:@"Green"];
-	[chart addSlicePortion:0.1 withName:@"Yellow"];
-	[chart addSlicePortion:0.1 withName:@"Pink"];
+    [chart addSlicePortion:0.1 withName:@"Orange" andImage:nil];
+	[chart addSlicePortion:0.2 withName:@"Fandango" andImage:nil];
+	[chart addSlicePortion:0.1 withName:@"Blue" andImage:nil];
+	[chart addSlicePortion:0.1 withName:@"Cerulean" andImage:nil];
+	[chart addSlicePortion:0.3 withName:@"Green" andImage:nil];
+	[chart addSlicePortion:0.1 withName:@"Yellow" andImage:nil];
+	[chart addSlicePortion:0.1 withName:@"Pink" andImage:nil];
 	return chart;
 }
 
@@ -92,13 +94,21 @@
   [self setNeedsDisplay];
 }
 
-- (void)addSlicePortion:(float)slicePortion withName:(NSString *)name {
+- (void)addSlicePortion:(float)slicePortion withName:(NSString *)name andImage:(UIImage *)image{
 	[sliceNames addObject:(name ? name : @"")];
   [slicePortions addObject:nFloat(slicePortion)];
 	float sumSoFar = [self pointAtIndex:-1];
 	[slicePointsIn01 addObject:nFloat(sumSoFar + slicePortion)];
+    
+    if (image != nil) {
+        UIImageView *iview = [[UIImageView alloc] initWithImage:image];
+        [iview setBackgroundColor:[UIColor colorWithWhite:0.9 alpha:0.1]];
+        [images addObject:iview];
+        [self addImages];
+    } else {
 	[self addLabelForLastName];
 }
+}
 
 - (void)drawRect:(CGRect)rect {
 	if ([slicePortions count] == 0) {
@@ -115,7 +125,7 @@
 	CGContextFillPath(context);
   
   CGContextSaveGState(context);
-  float shadowSize = radius / 15.0;
+    float shadowSize = radius / 30.0;
 	CGContextSetShadow(context, CGSizeMake(shadowSize, shadowSize), shadowSize);
   CGContextBeginTransparencyLayer(context, NULL);
   for (int i = 0; i < [slicePortions count]; ++i) {
@@ -157,6 +167,7 @@
                      initWithObjects:nFloat(0.0), nil];
   sliceNames = [NSMutableArray new];
   nameLabels = [NSMutableArray new];
+    images = [NSMutableArray new];
   colorspace = CGColorSpaceCreateDeviceRGB();    
 }
 
@@ -174,7 +185,7 @@
 	CGContextAddPath(context, path);
 	CGFloat red, green, blue;
 	[self getRGBForIndex:index red:&red green:&green blue:&blue];
-	CGContextSetRGBFillColor(context, red, green, blue, 0.35);
+	CGContextSetRGBFillColor(context, red, green, blue, 0.9);
 	CGContextFillPath(context);
 	CGContextRestoreGState(context);
 	
@@ -195,7 +206,7 @@
 	CGContextClip(context);
 	CGContextAddPath(context, path);
 	CGContextSetLineWidth(context, 0.5);
-	UIColor* darken = [UIColor colorWithWhite:0.0 alpha:0.2];
+	UIColor* darken = [UIColor colorWithWhite:0.2 alpha:0.6];
 	CGContextSetStrokeColorWithColor(context, darken.CGColor);
 	CGContextStrokePath(context);
 	CGContextRestoreGState(context);
@@ -209,7 +220,7 @@
 	CGFloat red, green, blue;
 	[self getRGBForIndex:index red:&red green:&green blue:&blue];
 	CGFloat components[8] = {red, green, blue, 0.9,
-    sqrt(red), sqrt(green), sqrt(blue), 0.15};
+    sqrt(red), sqrt(green), sqrt(blue), 0.81};
 	return CGGradientCreateWithColorComponents(colorspace, components,
                                              locations, num_locations);
 }
@@ -221,7 +232,7 @@
 	}
 		
 	NSString* text = [sliceNames lastObject];
-	CGSize textSize = [text sizeWithFont:[UIFont boldSystemFontOfSize:fontSize]];
+	CGSize textSize = [text sizeWithAttributes:@{ NSFontAttributeName : [UIFont boldSystemFontOfSize:fontSize] }];
 
 	// Find the angle of the relevant corners.
 	float cornerDist[2] = {
@@ -281,6 +292,58 @@
 		[self moveInLabel:index];
 	}
 }
+- (void)addImages {
+    NSInteger size = 17;
+    
+    // Find the angle of the relevant corners.
+    float cornerDist[2] = {
+        (self.frame.size.width - size) / 2,
+        (self.frame.size.height - size) / 2};
+    float cornerAngles[4];
+    cornerAngles[0] = atan2(cornerDist[1], cornerDist[0]);
+    cornerAngles[1] = M_PI - cornerAngles[0];
+    cornerAngles[2] = cornerAngles[0] + M_PI;
+    cornerAngles[3] = cornerAngles[1] + M_PI;
+    
+    // Find out which wall the center ray will hit.
+    int index = [slicePortions count] - 1;
+    float rayAngle = ([self pointAtIndex:index] +
+                      [self pointAtIndex:(index + 1)]) * M_PI;
+    int i;
+    for (i = 0; i < 4 && rayAngle > cornerAngles[i]; ++i);
+    i = i % 4;  // i might end up as 4 out of the loop
+    
+    // Find the hit point.  This is the point where the ray hits the frame, inset
+    // by half of textSize.  It's the farthest away we can put the center of the
+    // text while keeping it within frame and along the ray central to this slice.
+    float hitPoint[2];
+    float dist = (i % 2 == 0 ? cornerDist[0] : cornerDist[1]);
+    if (i > 1) dist *= -1;
+    hitPoint[i % 2] = dist;
+    float delta[2] = {cos(rayAngle), sin(rayAngle)};
+    float t = dist / delta[i % 2];
+    hitPoint[1 - (i % 2)] = t * delta[1 - (i % 2)];
+    
+    int hitOriginX = hitPoint[0] + centerX - size / 2;
+    int hitOriginY = hitPoint[1] + centerY - size / 2;
+    
+    UIImageView *iview = [images lastObject];
+    iview.frame = CGRectMake(hitOriginX, hitOriginY, size, size);
+    [self addSubview:iview];
+    
+    // Reposition the labels and/or resize the radius as needed to fit.
+    float iviewDist = [self approxDistFromCenter:iview.frame];
+    if (iviewDist < radius / kRadiusPortion) {
+        radius = iviewDist * kRadiusPortion;
+        [self movePreviousImagessIn];
+    } else {
+        [self moveInImage:index];
+    }
+    
+    if ([[slicePortions objectAtIndex:index] floatValue] <= 0) {
+        [iview setHidden:YES];
+    }
+}
 
 - (void)getRGBForIndex:(int)index red:(float *)red green:(float *)green blue:(float *)blue {
   if (colors) {
@@ -316,6 +379,20 @@ float dist(float x1, float y1, float x2, float y2) {
 	return distance;
 }
 
+
+- (void)moveInImage:(int)index {
+    float outerRadius = radius / kRadiusPortion;
+    UIImageView* iview = [images objectAtIndex:index];
+    float distance = [self approxDistFromCenter:iview.frame];
+    float excessDist = distance - outerRadius;
+    if (excessDist < 5.0) return;
+    float rayAngle = ([self pointAtIndex:index] +
+                      [self pointAtIndex:(index + 1)]) * M_PI;
+    iview.frame = CGRectOffset(iview.frame,
+                               (int)(-cos(rayAngle) * excessDist),
+                               (int)(-sin(rayAngle) * excessDist));	
+}
+
 - (void)moveInLabel:(int)index {
 	float outerRadius = radius / kRadiusPortion;
 	UILabel* label = [nameLabels objectAtIndex:index];
@@ -329,6 +406,12 @@ float dist(float x1, float y1, float x2, float y2) {
 							   (int)(-sin(rayAngle) * excessDist));	
 }
 
+- (void)movePreviousImagessIn {
+    for (int index = 0; index < [slicePortions count] - 1; ++index) {
+        [self moveInImage:index];
+    }
+}
+
 - (void)movePreviousLabelsIn {
 	for (int index = 0; index < [slicePortions count] - 1; ++index) {
 		[self moveInLabel:index];
@@ -340,4 +423,12 @@ float dist(float x1, float y1, float x2, float y2) {
 	return [(NSNumber*)[slicePointsIn01 objectAtIndex:index] floatValue];
 }
 
+// Whether to show the labels
+- (void)showLabels:(BOOL)show {
+    for (int i = 0; i < nameLabels.count; i++) {
+        // [nameLabels[i] setHidden:!show];
+        [images[i] setHidden:show];
+    }
+}
+
 @end
diff --git a/CodeTimestamps.m b/CodeTimestamps.m
index 5ab3943..748d65e 100644
--- a/CodeTimestamps.m
+++ b/CodeTimestamps.m
@@ -243,7 +243,7 @@ void LogTimestampChunkInMethod(const char *fnName, int lineNum, BOOL isStart, BO
         lastStamp = chunkStamp;
       }
       if (thisThreadHadChunks) {
-        NSLog(@"++ Chunk = %@, avg time = %d nsec", chunkName,
+        NSLog(@"++ Chunk = %@, avg time = %llu nsec", chunkName,
               totalNanoSecsThisThread / numRunsThisThread);
       }
       [chunkData removeAllObjects];
